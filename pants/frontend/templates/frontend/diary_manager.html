{% extends "frontend/common/main_template.html" %}
{% load static %}
{% block page_title %}Meal Diary{% endblock %}

{% block content %}
    <form id="diary_entry_form" class="flex-row-start">
        <span>
            <button id="time-text" class="text-only" type="button" onclick="change_time()">Just now,</button>
            <span>I ate</span>
        </span>
        <div class="float_input-group" id="datetime-group">
            <float-input id="date" label="Date" type="date" style="display: none"></float-input>
            <float-input id="time" label="Time" type="time" style="display: none"></float-input>
        </div>
        <div class="float_input-group">
            <float-input id="amount" label="Amount" extra="style='text-align:right;max-width:6em'"></float-input>
            <float-input id="unit" label="Unit" type="select">
                <option value="weight">Grams</option>
                <option value="servings">Servings</option>
            </float-input>
        </div>
        <span>of</span>
        {#        <float-input id="component" label="Food" ></float-input>#}
        <input id="component">
    <button class="dark" type="button" onclick="create_diaryfood()">Add</button>
    </form>
    <div id="chart-container">
        <canvas id="chart"></canvas>
    </div>

{% endblock %}
{% block css %}
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tagify/3.17.7/tagify.min.css"
          integrity="sha512-hqxNYuIWMQISqScYH0xQ3i8kH4MMxhJYlp7mfYvBGJKSGyliqk7SXRK3MxBuUnSwA1XeV+S+y3ad4oF+xD6kpA=="
          crossorigin="anonymous"/>
    <style>
        #diary_entry_form > span
        {
            margin-left: 1em;
            margin-right: 1em;
        }
    #chart-container{
        width: 100%;
        height: 8em;
        position: relative;
        resize: vertical;
        overflow: auto;
    }
    </style>
{% endblock %}
{% block js %}
    {#    TODO: Is this necessary? We don't really need time conversion between timezones if we can help it#}
    {#    <script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/1.24.1/luxon.min.js" integrity="sha512-IdHIbxMZbKEa2OSI0CcqlrgENti38ygeddwz6wOwjzSWygIYeJvHkvU1EFBCT1L471JM2QX36y8exP2QhgcB3A==" crossorigin="anonymous"></script>#}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tagify/3.17.7/tagify.min.js"
            integrity="sha512-Kngmb6PkMXOkg76SHxpcsy2HQasqClt4KKl7jUe5IuG+Jg7l8PSjXtPNHKE+8wBIHARedIiOEqaca+hZQIzD/A=="
            crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script>
{#    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/0.5.7/chartjs-plugin-annotation.min.js" integrity="sha512-9hzM/Gfa9KP1hSBlq3/zyNF/dfbcjAYwUTBWYX+xi8fzfAPHL3ILwS1ci0CTVeuXTGkRAWgRMZZwtSNV7P+nfw==" crossorigin="anonymous"></script>#}
    <script src="{% static 'js/chartjs/chartjs-plugin-annotation-custom.js'%}"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@0.7.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script>
        // Setup variables to access form inputs
        let date = document.getElementById('date');
        let time = document.getElementById('time');
        let amount = document.getElementById('amount');
        let unit = document.getElementById('unit');
        let component = document.getElementById('component');

        // Setup obvious defaults, if you are coming here you probably want to record what happened right now
        let sysDate = new Date(),
            userDate = new Date(Date.UTC(sysDate.getFullYear(), sysDate.getMonth(), sysDate.getDate(), sysDate.getHours(), sysDate.getMinutes(), 0));
        date.valueAsDate = userDate;
        time.valueAsDate = userDate;

        let time_state = 'just-now';
        let change_time_button = document.getElementById('time-text');
        // Setup progressively being able to specify more specifically when you ate the food
        function change_time() {
            if(time_state === 'just-now'){
                time_state = 'today-at';
                change_time_button.innerText = 'Today at';
                time.style.display = 'inherit';

                document.getElementById('datetime-group').after(change_time_button.nextElementSibling);

            } else if (time_state === 'today-at'){
                time_state = 'on-datetime';

                let new_text = document.createElement('span');
                new_text.innerText = 'On';
                change_time_button.replaceWith(new_text);

                date.style.display = 'inherit';
            }
        }

        function create_diaryfood(){
            let component_data = JSON.parse(component.value)[0];
            pants.create_diaryfood({
                'start_time':(new Date(date.value + "T" + time.value)).toISOString(),
                // Set 'servings' or 'weight'
                [unit.value]:amount.value,
                // Set 'of_ingredient' or 'of_recipe' or 'name' depending on what has been entered
                [component_data.url === undefined
                    ? 'name'
                    : (component_data.url.split("/").slice(-3)[0] === 'recipe'
                        ? 'of_recipe'
                        : 'of_ingredient')
                    ]: component_data.url === undefined ? component_data.name : component_data.url,
            })
        }

        // Setup combobox for selecting/specifying ingredient/recipe/one off food
        function tagTemplate(component) {
            return `
                <tag title="${component.url}"
                        contenteditable='false'
                        spellcheck='false'
                        tabIndex="-1"
                        class="tagify__tag"
                        ${this.getAttributes(component)}>
                    <x title='' class='tagify__tag__removeBtn' role='button' aria-label='remove tag'></x>
                    <div>
                        <i class='fas fa-${component.component_type === 'recipe' ? 'hamburger' : 'carrot'}'></i>
                        <span class='tagify__tag-text'>${component.name}</span>
                    </div>
                </tag>
            `
        }

        function suggestionItemTemplate(component) {
            return `
                <div ${this.getAttributes(component)}
                    class='tagify__dropdown__item'
                    tabindex="0"
                    role="option">
                    <i class='fas fa-${component.component_type === 'recipe' ? 'hamburger' : 'carrot'}'></i>
                    <strong>${component.name}</strong>
                </div>
            `
        }

        let tagify = new Tagify(component, {
            maxTags: 1,
            whitelist: [],
            templates: {
                tag: tagTemplate,
                dropdownItem: suggestionItemTemplate,
                dropdownItemNoMatch: function (data) {
                    return `No match. Create one time entry for: ${data.value}`
                }
            },
            dropdown: {
                enabled: 1,
                searchKeys: ['name']
            }
        })
        let controller; // for aborting the call
        // listen to any keystrokes which modify tagify's input
        tagify.on('input', onInput)

        function onInput(e) {
            var value = e.detail.value;
            tagify.settings.whitelist.length = 0; // reset the whitelist

            // https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort
            {#controller && controller.abort();#}
            {#controller = new AbortController();#}

            // show loading animation and hide the suggestions dropdown
            tagify.loading(true).dropdown.hide.call(tagify);

            pants.search_components(value)
                .then(function (response) {
                    let results = response.results.map(component => {
                        // Give each recipe a 'value' that Tagify will use and the API will understand
                        component['value'] = component['url'];
                        // Give each component a component_type that we can use to differentiate between ingredients and recipes
                        component['component_type'] = component.url.split('/').splice(-3)[0];
                        return component
                    })
                    // update whitelist Array in-place
                    tagify.settings.whitelist.splice(0, results.length, ...results)
                    tagify.loading(false).dropdown.show.call(tagify, value); // render the suggestions dropdown
                })
        }


        // Store a reference to the chart
        let chart;
        // Defines the categories in the charts,
        // also keeps track of normalized nutrient totals so we can annotate hit or missed targets later
        // and keeps track of the temporary nutrient amounts that are currently in the chart
        // 'nutrient': [current_total, temorary_nutrient_amount, min_target_value]
        let nutrient_totals_normalized = {
            "kilojoules": [0, 0, 0],
            "protein": [0, 0, 0],
            "fibre": [0, 0, 0],
            "carbohydrate": [0, 0, 0],
            "fat": [0, 0, 0],
            "sugar": [0, 0, 0],
            "saturatedfat": [0, 0, 0],
            "sodium": [0, 0, 0],
            "cost": [0, 0, 0],
        };
        const CURRENT_TOTAL = 0, TEMPORARY_NUTRIENT = 1, MIN_TARGET = 2;
        /**
         * Draw a graph of the last 24 hours of diary food entries.
         * Requires a target_set to be passed in so that it can normalize and annotate the data
         * @param target_set
         */
        function draw_graph(target_set){
            let min_start_time = new Date();
            // Set it back 24 hours
            let time_range = (1000*60*60) * 24
            min_start_time.setTime(min_start_time.getTime() - time_range);
            pants.get_diaryfood({
                min_start: min_start_time.toISOString()
            })
            .then(resp=> {
                // Graph each diaryfood as a dataset in a stacked bar chart
                // Normalize each stack by the maximums

                let colors = [
                    '#0C79B4',
                    '#27B2A3',
                    '#C2B04F',
                    '#DDA63E',
                    '#E2BD0F',
                ]

                let datasets = [];
                resp.results.forEach((diaryfood, idx)=>{
                    datasets.push({
                        label: diaryfood.name || '[No Name]',
                        backgroundColor: colors[idx % colors.length],
                        data: Object.keys(nutrient_totals_normalized).map(nutrient=>{
                            // Normalize each entry by the target maximum
                            let normalized_value = (diaryfood[nutrient] || 0) / (target_set.maximum[nutrient] || 1);
                            nutrient_totals_normalized[nutrient][CURRENT_TOTAL] += normalized_value;
                            return normalized_value;
                        })
                    })
                })
                let annotations = []
                // Add the max as a line annotation (it's the same for every category because it's normalized)
                annotations.push({
                                id: '100-percent',
                                type: 'line',
                                mode: 'horizontal',
                                scaleID: 'y-axis-0',
                                value: '1',
                                borderColor: 'red',
                                borderWidth: 1,
                            });
                // Keep track of each target nutrients's mins as box annotations
                Object.keys(nutrient_totals_normalized).forEach((nutrient, idx)=>{
                    let min_val = parseFloat(target_set.minimum[nutrient])
                    let min_val_normalized = (min_val / (target_set.maximum[nutrient] || 1))
                    let max_val = parseFloat(target_set.maximum[nutrient])
                    // Store the min value normalized for other computations
                    nutrient_totals_normalized[nutrient][MIN_TARGET] = min_val_normalized;
                    annotations.push({
                        type: 'box',
                        yScaleID: 'y-axis-0',
                        xScaleID: 'x-axis-0',
                        id: nutrient + '-min',
                        yMax: min_val_normalized,
                        yMin: min_val_normalized,
                        xMin: idx - 0.5,
                        xMax: idx + 0.5,
                        borderColor: 'red',
                        borderWidth: 1,
                        backgroundColor: 'transparent',
                    });
                    // Color the column depending on if target hit or missed
                    annotations.push({
                        type: 'box',
                        id: nutrient + '-target-status',
                        yScaleID: 'y-axis-0',
                        xScaleID: 'x-axis-0',
                        xMin: idx - 0.5,
                        xMax: idx + 0.5,
                        backgroundColor: (nutrient_totals_normalized[nutrient][CURRENT_TOTAL] < min_val_normalized || nutrient_totals_normalized[nutrient][CURRENT_TOTAL] > 1) ? 'rgba(255,0,0,0.05)' : 'rgba(0,255,0,0.05)',
                    });
                    // And because boxes in the annotations library do not yet support labels, we have to add invisible
                    // lines so we can label each minimum and maximum. Ugh. TODO use box labels instead once annotations plugin supports it
                    // Okay so now I'm using this library, but the positioning is not as expected and somewhat broken, so
                    // I'm dealing with it by collapsing the box to a point
                    if(min_val !== max_val){
                        annotations.push({
                            type: 'box',
                            id: nutrient + '-min-label',
                            yScaleID: 'y-axis-0',
                            xScaleID: 'x-axis-0',
                            yMax: min_val_normalized,
                            yMin: min_val_normalized,
                            xMin: idx - 0.5,
                            xMax: idx - 0.5,
                            borderColor: 'transparent',
                            borderWidth: 0,
                            backgroundColor: 'transparent',
                            label:{
                                content: min_val.toFixed(1),
                                enabled: true,
                                position: "right",
                                yAdjust: -8,
                                xPadding: 0,
                                yPadding: 0,
                                fontColor: 'rgba(0,0,0,0.5)',
                                fontSize: 8,
                                cornerRadius: 0,
                                backgroundColor: 'transparent'
                            }
                        });
                    }
                    // Also annotate max values
                    annotations.push({
                        type: 'box',
                        id: nutrient + '-max-label',
                        yScaleID: 'y-axis-0',
                        xScaleID: 'x-axis-0',
                        yMax: 1,
                        yMin: 1,
                        xMin: idx + 0.5,
                        xMax: idx + 0.5,
                        borderColor: 'transparent',
                        borderWidth: 0,
                        backgroundColor: 'transparent',
                        label:{
                            content: min_val.toFixed(1),
                            enabled: true,
                            position: "left",
                            yAdjust: +8,
                            xPadding: 4,
                            yPadding: 0,
                            fontColor: 'rgba(0,0,0,0.5)',
                            fontSize: 8,
                            cornerRadius: 0,
                            backgroundColor: 'transparent'
                        }
                    });
                });

                // Annotate the bar chart stack by providing an annotation for the last dataset
                if(datasets.length > 0){
                    datasets[datasets.length - 1]['datalabels'] = {
                        display: true,
                        color: 'black',
                        anchor: 'end',
                        clamp: true,
                        align: 'top',
                        offset: 0,
                        padding: 0,
                        formatter: function (value, context) {
                            // Get the sum of the stack for the current label and display that instead
                            let label = context.chart.data.labels[context.dataIndex];
                            return (nutrient_totals_normalized[label][CURRENT_TOTAL] * 100).toFixed(0) + '%';
                        }
                    }
                }

                var ctx = document.getElementById('chart').getContext('2d');
                chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Object.keys(nutrient_totals_normalized),
                        datasets: datasets
                    },
                    options: {
                        legend: {
                            position:'left',
                            reverse: true, // Want to show in order of datasets in the stack (TODO this makes the most recent meal show at the bottom... is that what we want?)
                        },
                        maintainAspectRatio: false,
                        scales: {
                            yAxes: [{
                                id: 'y-axis-0',
                                stacked:true,
                                ticks: {
                                    beginAtZero: true
                                }
                            }],
                            xAxes: [{
                                id: 'x-axis-0',
                                stacked:true
                            }]
                        },
                        annotation:{
                            annotations:annotations
                        },
                        plugins: {
                            datalabels:{
                                display: false // disable, only want to show a label at the top of the stack (so I will add it to the last dataset)
                            }
                        }
                    },
                });
            })
        }

        let user_target_set;
        document.addEventListener('DOMContentLoaded', ()=>{
            // Get the user's current daily target so that we can normalize all charts
            pants.get_target()
                .then(resp=>{
                    user_target_set = resp.results[0];
                    draw_graph(user_target_set);
                })
        })

        // Set up a listener for when the user is adding a diary entry.
        // We can add a temporary dataset to show them what the food they are about to add will do to their targets
        function add_temporary_dataset(target_set){
            let has_changed = false;
            // Remove the previously added temporary dataset if available
            for(let [idx, dataset] of chart.data.datasets.entries()){
                if(dataset.isTemporary){
                    has_changed = true;
                    chart.data.datasets.splice(idx, 1);
                    break;
                }
            }
            // Re-enable the labels on the top-most permanent dataset
            if(chart.data.datasets.length > 0){
                chart.data.datasets[chart.data.datasets.length - 1].datalabels.display = true
            }
            // Re-compute the background color annotations based on the permanent totals only
            for (let nutrient in nutrient_totals_normalized){
                // TODO extract this to a sane location
                let val = nutrient_totals_normalized[nutrient][CURRENT_TOTAL];
                chart.annotation.elements[nutrient + "-target-status"].options.backgroundColor= (val < nutrient_totals_normalized[nutrient][MIN_TARGET] || val > 1) ? 'rgba(255,0,0,0.05)' : 'rgba(0,255,0,0.05)';
            }

            let components_data = JSON.parse(component.value || '[]');
            // Check to ensure we have enough valid information to add the temporary dataset
            if(amount.value === '' || unit.value === '' || components_data.length === 0){
                if(has_changed) chart.update();
                return;
            }
            // Disable the labels on the top-most permanent dataset if it exists
            if(chart.data.datasets.length > 0){
                chart.data.datasets[chart.data.datasets.length - 1].datalabels.display = false
            }

            let diaryfood = components_data[0];
            // Nutrient values on the food are stored per KG
            // Scale according to weight/servings selected
            let amount_in_grams = parseFloat(amount.value) * (unit.value === 'servings' ? parseFloat(diaryfood.serving) : 1.0);
            let scale_factor = amount_in_grams / 1000;
            chart.data.datasets.push({
                isTemporary: true,
                label: diaryfood.name || '[No Name]',
                backgroundColor: 'rgba(0,0,0,0.2)',
                borderColor: 'red', // TODO wrong property? This doesn't appear to be showing in the graph
                data: Object.keys(nutrient_totals_normalized).map(nutrient=>{
                    let nutrient_per_amount = (parseFloat(diaryfood[nutrient]) || 0) * scale_factor;
                    // Normalize each entry by the target maximum
                    let normalized_value = nutrient_per_amount / (target_set.maximum[nutrient] || 1);
                    nutrient_totals_normalized[nutrient][TEMPORARY_NUTRIENT] = normalized_value;
                    return normalized_value;
                }),
                datalabels: {
                    display: true,
                    color: 'black',
                    anchor: 'end',
                    clamp: true,
                    align: 'top',
                    offset: 0,
                    padding: 0,
                    formatter: function (value, context) {
                        // Get the sum of the stack for the current label and display that instead
                        let label = context.chart.data.labels[context.dataIndex];
                        let val = nutrient_totals_normalized[label][CURRENT_TOTAL] + nutrient_totals_normalized[label][TEMPORARY_NUTRIENT];
                        // We can also conveniently update the background annotation to reflect the new status
                        // TODO extract this to a sane location
                        chart.annotation.elements[label + "-target-status"].options.backgroundColor= (val < nutrient_totals_normalized[label][MIN_TARGET] || val > 1) ? 'rgba(255,0,0,0.05)' : 'rgba(0,255,0,0.05)';
                        return (val * 100).toFixed(0) + '%';
                    }
                }
            });
            chart.update();
        }
        amount.addEventListener('change', ()=>{add_temporary_dataset(user_target_set)})
        unit.addEventListener('change', ()=>{add_temporary_dataset(user_target_set)})
        component.addEventListener('change', ()=>{add_temporary_dataset(user_target_set)})
    </script>
{% endblock %}